# Ideal City Build Automation Playbook

## 1. What already works
- Build plans are generated by the backend `BuildPlanAgent` (`backend/app/core/ideal_city/build_plan_agent.py`) and enqueued through `BuildScheduler` under `backend/data/ideal_city/build_queue/build_queue.jsonl`.
- Mods expose executable entry points through their `mod.json` (for example `mods/gm4.balloon_animals/mod.json` supplies the three build commands that should create the balloon showcase).
- `tools/auto_build.py` materialises queued plans: it resolves the mod hooks, writes an execution log with the exact command payload, and (if RCON is configured) dispatches those commands to the running Paper server.

## 2. Verifying executability
- **Queue health** – run `python tools/sync_mods.py --queue backend/data/ideal_city/build_queue/build_queue.jsonl` or inspect the file directly to confirm that plans are being created.
- **Worker loop** – launch `python tools/auto_build.py --watch --log-dir backend/data/ideal_city/build_queue/executed` in a tmux pane or the provided VS Code task. On each cycle it reloads manifests and consumes every pending plan.
- **Dispatch** – when the environment variables `MINECRAFT_RCON_HOST`, `MINECRAFT_RCON_PORT`, and `MINECRAFT_RCON_PASSWORD` are set, the worker enables live command dispatch (`RconClient.run`). Otherwise it still writes the command list so that an operator can copy-paste the functions manually.
- **Visibility** – every processed plan emits a JSON record in `backend/data/ideal_city/build_queue/executed/`. The payload includes `status`, `commands`, `mod_hooks`, `player_pose`, and `logged_at`. Failed or blocked plans land in the sibling `failed/` folder with the same schema plus diagnostic `notes`.
- **Runtime logs** – `logs/auto_build.log` shows a chronological trace of the worker (poll cycles, plan IDs, RCON success or failure). Server-side confirmation should be visible in `logs/latest.log` once the Paper instance actually executes the datapack functions.

## 3. Gaps to keep in mind
- A generated plan only carries placeholder-aware commands when a `player_pose` is present. If the pose is missing, the executor falls back to the raw manifest commands, which may omit the positional offsets that the structure expects.
- The queue currently stores plans indefinitely until the worker runs. If the worker is offline, `build_queue.jsonl` will grow but nothing is pushed into the world.
- The dispatched command list captures absolute coordinates (after placeholder substitution). Replaying the JSON as-is will rebuild the structure at the original location, not at a new target.

## 4. Making "command + filename" relocations real
1. **Adopt log files as the canonical artefact.** Each executed plan already produces a unique JSON file named after its `plan_id`. Treat this as the "filename" reference when we want to redeploy something.
2. **Add a replay CLI.** Create a helper (for example `python tools/replay_build_plan.py --plan backend/data/ideal_city/build_queue/executed/<plan_id>.json --world city_night --x 120 --y 65 --z -340 --yaw 45`). Internally:
   - Parse the executed log to read `mod_hooks` and the recorded command templates.
   - Pull the build command templates from the `ModManager` so we can re-apply placeholder substitution instead of reusing the baked absolute coordinates.
   - Inject the new pose (world, xyz, yaw, pitch) before calling `BuildExecutor._prepare_command`, then either print the resolved commands or push them through RCON.
3. **Guarantee pose capture.** Ensure the adjudication or story state step that enqueues the plan always supplies a `player_pose`. Without it the replay tool cannot compute the `{forward_*}` offsets.
4. **Optional: plan registry.** Maintain a lightweight index (e.g. `backend/data/ideal_city/build_queue/catalog.json`) that maps human-readable scenario tags ("night_market_balloon_showcase") to the latest executed `plan_id`. The replay CLI can look up a tag instead of a raw UUID.
5. **Permissions and safety.** Gate the replay command behind an explicit confirmation flag (e.g. `--dispatch`) so operators can dry-run and inspect the command list before touching the live world.

## 5. Operational checklist
- Before a play session, run the mod sync helper so manifests are up to date and the build queue is summarised.
- Keep one `auto_build.py --watch` process alive (the PID is stored in `auto_build.pid` for convenience). Confirm that `logs/auto_build.log` keeps ticking.
- When a community request approves a build, check the newly created JSON under `executed/` to verify the command payload matches the expectation (look for the `gm4_balloon_animals:build/setup_showcase` function call).
- To redeploy an existing build at a new site, invoke the replay CLI with the desired coordinates. The helper can hand the resolved `execute` commands to an op for manual `/function` execution if RCON is not available.
- Use `/planjump <plan_id>` in-game to teleport to the coordinates recorded in the executed plan log (the command reads the same JSON artefact exposed by the backend `GET /ideal-city/build-plans/executed/{plan_id}` endpoint).

Following the steps above keeps the build plan pipeline auditable and opens the door to your "command + filename" relocation workflow without changing the underlying datapack logic.
